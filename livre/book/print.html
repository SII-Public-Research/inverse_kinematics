<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inverse Kinetics</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Methode.html"><strong aria-hidden="true">1.1.</strong> Methode</a></li><li class="chapter-item expanded "><a href="Organisation.html"><strong aria-hidden="true">1.2.</strong> Organisation du répertoire</a></li></ol></li><li class="chapter-item expanded "><a href="2_dof.html"><strong aria-hidden="true">2.</strong> Bras 2 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_2_dof.html"><strong aria-hidden="true">2.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="3_dof.html"><strong aria-hidden="true">3.</strong> Bras 3 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_3_dof.html"><strong aria-hidden="true">3.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="4_dof.html"><strong aria-hidden="true">4.</strong> Bras 4 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_4_dof.html"><strong aria-hidden="true">4.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="5_dof.html"><strong aria-hidden="true">5.</strong> Bras 5 DdL</a></li><li class="chapter-item expanded "><a href="levenberg.html"><strong aria-hidden="true">6.</strong> Méthode alternative - Algorithme d'optimisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_4_dof_levenberg.html"><strong aria-hidden="true">6.1.</strong> Code</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Inverse Kinetics</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ce livre a pour but de présenter la démarche expérimentale que nous avons mise en œuvre afin de maîtriser, ou du moins mieux appréhender, les techniques de cinématiques inverses utilisées en robotique. </p>
<p>Le but final étant de pouvoir contrôler de manière précise un bras robotique comprenant 5 degrés de libertés. </p>
<h1 id="outils"><a class="header" href="#outils">Outils</a></h1>
<p>Au sein de notre équipe, nous avons un petit faible pour le langage RUST et son implémentation dans des cibles embarqués. 
Nous avons donc souhaité utiliser ce langage pour la partie embarquée.</p>
<p>Du Python sera utilisé pour tester les approches mathématiques mises en avant afin de rapidement modéliser un système. Les principales librairies utilisées étant <strong>numpy</strong> et <strong>sympy</strong></p>
<p>Enfin, nous créerons un lien entre la commande moteur et les algorithmes en utilisant l’environnement ROS (robot operating system). </p>
<h1 id="matériel"><a class="header" href="#matériel">Matériel</a></h1>
<p>Notre étude se voulant pratique, nous sommes parti sur un bras robotique disponible dans le commerce.</p>
<p>Les différents liens utiles étant :</p>
<ul>
<li><a href="https://www.gotronic.fr/art-bras-robotique-joy-it-robot02-26637.html">Achat</a></li>
<li><a href="https://www.gotronic.fr/pj2-robot02-guide-de-montage-1556.pdf">Montage</a></li>
</ul>
<p>Afin de contrôler le bras, nous avons déterré un vieux shield moteur que nous avions déjà utilisé auparavant, en ajoutant des fonctionnalités de contrôle de servomoteurs.
Les différents liens utiles étant :</p>
<ul>
<li><a href="https://www.makerbuying.com/docs/new-sna41">Présentation</a></li>
<li><a href="https://github.com/SII-Public-Research/sna41-motorshield">crate RUST</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="méthode"><a class="header" href="#méthode">Méthode</a></h1>
<p>Nous décomposerons l'étude du bras final en plusieurs sous-parties, en partant d'un système comprenant 2 degrés de libertés et en en ajoutant un par un jusqu'à atteindre le nombre de degrés de libertés du bras réel. 
Nous espérons ainsi pouvoir identifier à chaque étape les difficultés additionnels liés à chaque ajout. </p>
<p>Pour chaque modèle, nous utiliserons la convention de <a href="https://fr.wikipedia.org/wiki/Denavit-Hartenberg">Denavit-Hartenberg</a> pour visualiser de façon schématique le système. 
Ensuite, nous définirons les matrices de transition pour chaque liaison, même si dans les premiers cas d'étude une approche graphique pourrait amener à une solution plus rapide. </p>
<p>Enfin, nous préciserons pour chaque système une solution, relié à un script python puis une implémentation en Rust sur un système réel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation-du-répertoire"><a class="header" href="#organisation-du-répertoire">Organisation du répertoire</a></h1>
<p>Le répertoire est composé de 2 dossiers principaux. </p>
<p>Chaque système sera représenté et étudié dans un sous-dossier du dossier ''exemples''.</p>
<h2 id="livre"><a class="header" href="#livre"><strong>livre</strong></a></h2>
<p><em>Créé à partir du template <a href="https://rust-lang.github.io/mdBook/index.html">md-book</a> fourni par la crate Rust du même nom.</em></p>
<p>Vous pouvez lancer la lecture du livre via la commande suivante :</p>
<pre><code class="language-bash">mdbook build --open
</code></pre>
<h2 id="exemples"><a class="header" href="#exemples"><strong>exemples</strong></a></h2>
<p><em>Comprend l’environnement prêt à être déployé sur une raspberry pi. Nous vous invitons à vous renseigner sur l'utilisation de <a href="https://docs.ros.org/en/humble/index.html">ROS2</a> avant d'utiliser cette partie.</em></p>
<p>Le programme est divisé en deux packages :</p>
<ul>
<li>
<p><strong>command</strong> : c'est la partie algorithmie, qui prendra en entrée un message de type <em>geometry_msgs/msg/Point</em> pour le transformer en message de type <em>messages/msg/MotorsAngles</em>.</p>
</li>
<li>
<p><strong>motors_ctr</strong> : c'est la partie contrôle des moteurs qui prendra en entré un message de type <em>messages/msg/MotorsAngles</em> afin de le transformer en commande moteurs.</p>
</li>
</ul>
<p>Vous devrez dans un premier temps compiler le programme :</p>
<pre><code class="language-bash">cd exemples/$exemple_name
colcon build
</code></pre>
<p>Une fois réalisé, il est important de sourcer les exécutables générés afin que ROS puisse les retrouver.</p>
<pre><code class="language-bash">. install/setup.bash
</code></pre>
<p>Vous pouvez utiliser le ficher .launch qui permet de lancer les deux nodes utilisées dans le processus de contrôle du bras. </p>
<pre><code class="language-bash">ros2 launch $exemple_name.py
</code></pre>
<p>Enfin, vous devrez utiliser un autre terminal afin d'envoyer une commande de type <em>geometry_msgs/msg/Point</em> et ainsi contrôler le bras en position. </p>
<pre><code class="language-bash">ros2 topic pub --once /cmd_arm geometry_msgs/msg/Point &quot;{x = 0.0, y = 0.0, z = 200.0}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-dof-robotic-arm"><a class="header" href="#2-dof-robotic-arm">2 dof robotic arm</a></h1>
<p>Commençons par monter uniquement deux servomoteurs sur notre bras. 
En respectant les conventions de <strong>Denavit-Hartenberg</strong>, nous pouvons construire le schéma représentatif :
<img src="images/2dof_luna_arm.drawio.png" alt="schema_2dof" /></p>
<p>Une fois la position initiale du robot choisie, ici un angle de 90° entre le segment <strong>OA</strong> et <strong>AM</strong>, nous pouvons écrire les matrices de transitions correspondantes :</p>
<p>$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; 0 &amp; S1 &amp; 0\\
S1 &amp; 0 &amp; -C1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; -S2 &amp; 0 &amp; a_2C2\\
S2 &amp; C2 &amp; 0 &amp; a_2S2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Avec $$ S1 = sin(θ_1), S2 = sin(θ_2), C1 = cos(θ_1), C2 = cos(θ_2) $$</p>
<p>Une fois les matrices de transitions pour chaque liaisons réalisés, nous pouvons faire leur produit matriciel afin d'obtenir la matrice caractéristique du système étudié. </p>
<p>$$
T02 = 
\left(\begin{array}{cc}
C1C2 &amp; -C1S2 &amp; S1 &amp; a_2C1C2\\
S1C2 &amp; -S1S2 &amp; -C1 &amp; a_2S1C2\\
S2 &amp; C2 &amp; 0 &amp; a_1 + a_2S2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Dans ce cas précis, avec uniquement deux liaisons, le système est relativement simple et nous pouvons nous contenter d'utiliser la dernière colonne de la matrice qui représente les équations de la position finale du bras en fonction des angles des moteurs.</p>
<p>$$ 
\begin{cases}
x = a_2 * cos(θ_1) * cos(θ_2) \\
y = a_2 * sin(θ_1) * cos(θ_2) \\
z = a_1 + a_2 * sin(θ_2)
\end{cases}
$$</p>
<p>Pour <strong>θ<sub>1</sub></strong>, nous pouvons calculer son sinus et son cosinus à partir des équations de Y et X :
$$
\begin{cases}
sin(θ_1)  = \cfrac{y}{a_2 * cos(θ_2)}\\
cos(θ_1) = \cfrac{x}{a_2 * cos(θ_2)}
\end{cases}
$$</p>
<p>on obtient ainsi <strong>θ<sub>1</sub></strong> en faisant le calcul eq(y) / eq(x) :</p>
<p>$$
θ_1 = atan2(\cfrac{y}{x})
$$</p>
<p>Pour <strong>θ<sub>2</sub></strong>, nous pouvons calculer son sinus et son cosinus à partir des équations de Z et X (ou Y) :
$$
\begin{cases}
sin(θ_2) = \cfrac{z - a_1}{a_2}\\
cos(θ_2) = \cfrac{x}{a_2 * cos(θ_1)}
\end{cases}
$$</p>
<p>Enfin, nous pouvons obtenir l'angle <strong>θ<sub>2</sub></strong> de la même manière que <strong>θ<sub>1</sub></strong> :</p>
<p>$$
θ_2 = atan2(\cfrac{(z - a_1) * cos(θ_1)}{x})
$$</p>
<p>Nous pouvons observer qu'il est relativement facile dans le cas de deux liaisons d'obtenir une cinématique inverse du système. </p>
<p>En revanche, le système est limité et ne peut atteindre qu'un champ réduit de points, correspondant à une sphère de rayon a2. 
Nous notons également que dans notre cas d'étude, les servomoteurs ont une portée comprise entre 0 et 180°.</p>
<p>Afin de rendre le programme utilisable facilement, nous avons donc prévu une correction de la commande en Z, qui sera calculé à partir des paramètres d'entrés (X, Y). Cela évite de devoir calculer précisément une position du bras pour obtenir un déplacement réalisable. </p>
<p>$$
z = \sqrt{a_2^2 - x^2 - y^2} + a_1
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code"><a class="header" href="#code">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene, romain.saboret
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 0.0
y = 0.0
z = 190.0
print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 


# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0

# We first check if the command is a possible input. If not, we change the z target
z = np.sqrt(a2**2 - x**2 - y**2) + a1
print(f'Zm = {z}')
print('')

# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.sin(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_2 = trans_mat_0_1 @ trans_mat_1_2
#print(f'trans_mat_0_2 = {trans_mat_0_2}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_2[0, 3], x)
eq2 = sp.Eq(trans_mat_0_2[1, 3], y)
eq3 = sp.Eq(trans_mat_0_2[2, 3], z)

sp.simplify(trans_mat_0_2[0, 3])
sp.simplify(trans_mat_0_2[1, 3])
sp.simplify(trans_mat_0_2[2, 3])



# We can have S2 with Z eq
S2 = (z - a1) / a2
# Then, we can get 2 values for C2 according to eq cos² + sin² = 1
C2_pos = np.sqrt(1 - S2**2)
C2_neg = -np.sqrt(1 - S2**2)
# Finally, we got theta_2 from atan2
theta_2 = math.atan2(S2, C2_pos)
theta_2_bis = math.atan2(S2, C2_neg)
print(f'theta_2 = {np.mod(np.degrees(theta_2), 360)}')
print(f'theta_2_bis = {np.mod(np.degrees(theta_2_bis), 360)}')
# Note that we have two possible values for theta_2. 
# We noticed that the first one is all the time working fine on our case


# We can have S1 from Y eq
S1 = y / (a2 * np.cos(theta_2))
# We can have C1 with X eq
C1 = x / (a2 * np.cos(theta_2))
# Finally, we got theta_2 from atan2
theta_1 = math.atan2(S1, C1)
print(f'theta_1 = {np.mod(np.degrees(theta_1), 360)}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3_dof-robotic-arm"><a class="header" href="#3_dof-robotic-arm">3_dof robotic arm</a></h1>
<p>Ajoutons un servo-moteur à notre bras. 
Nous obtenons ainsi un système comprenant 3 degrés de libertés. </p>
<p>En respectant les conventions de <strong>Denavit-Hartenberg</strong>, nous pouvons construire le schéma représentatif :
<img src="images/3dof_luna_arm.drawio.png" alt="schema_3dof" /></p>
<p>Nous choisissons pour cette étude de changer la position initiale entre le segment <strong>OA</strong> et <strong>AB</strong>, que nous fixons à 180°. Pour la position initiale du 3ème moteur, nous choisissons un angle de 90° entre le segment <strong>AB</strong> et <strong>BM</strong>. Nous pouvons ainsi écrire les matrices de transitions correspondantes :</p>
<p>$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; 0 &amp; S1 &amp; 0\\
S1 &amp; 0 &amp; -C1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; -S2 &amp; 0 &amp; -a_2S2\\
S2 &amp; C2 &amp; 0 &amp; a_2C2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T23 = 
\left(\begin{array}{cc}
C3 &amp; -S3 &amp; 0 &amp; a_3C2\\
S3 &amp; C3 &amp; 0 &amp; a_3S2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>La matrice représentative du système est alors plus complexe, et l'on commence à distinguer quelques difficultés à trouver une solution simple au système : </p>
<p>$$
T03 = 
\left(\begin{array}{cc}
C1(C2C3 - S2S3) &amp; -C1(S2C3 + C2S3) &amp; S1 &amp; C1(-a_2S2 + a_3C23)\\
S1(C2C3 - S2S3) &amp; -S1(S2C3 + C2S3) &amp; -C1 &amp; S1(-a_2S2 + a_3C23)\\
S2C3 + S3C2 &amp; -S2S3 + C2C3 &amp; 0 &amp; a_1 + a_2C2 + a_3S23\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Cependant, en utilisant toujours uniquement les équations sur (X, Y, Z), on obtient un système à 3 équations et 3 inconnues qu'il est possible de résoudre. </p>
<p>$$ 
\begin{cases}
x = cos(θ_1)(-a_2 * sin(θ_2) + a_3 * cos(θ_2 + θ_3)) \\
y = sin(θ_1)(-a_2 * sin(θ_2) + a_3 * cos(θ_2 + θ_3))\\
z = a_1 + a_2 * sin(θ_2)
\end{cases}
$$</p>
<p>En effet, on constate qu'il est facile d'obtenir <strong>θ<sub>1</sub></strong>, en utilisant la même méthode que pour le bras 2ddl :
$$
θ_1 = atan2(\cfrac{y}{x})
$$</p>
<p>Ensuite, <strong>sin(θ<sub>3</sub>)</strong> est obtenu en faisant la somme des trois équations misent au carré, et en utilisant les propriétés du sinus sin(a-b) :
$$
sin(θ_3) = \cfrac{a_1^2 - a_2^2 - a_3^2 + x^2 + y^2 + z^2 - 2 * a_1 * z} {2 * a_2 * a_3}
$$</p>
<p>On récupère ensuite la valeur de <strong>cos(θ<sub>3</sub>)</strong> en utilisant la propriété <strong>cos² + sin² = 1</strong>
$$
C3 = ±\sqrt{1 - S3^2}
$$
On peut noter que l'on aura deux valeurs possibles de <strong>θ<sub>3</sub></strong>, qui correspondront à deux configurations possibles du bras. 
$$
θ_3 = atan2(\cfrac{S3}{C3})
$$</p>
<p>Une fois <strong>θ<sub>1</sub></strong> et <strong>θ<sub>2</sub></strong> obtenus, il est alors possible, en simplifiant les équations, de retrouver un système à deux équations et 2 inconnues (C2 et S2)
$$
soit :
\begin{cases}
k_1 = a_2 + a_3 * S3\\
k_2 = a_3 * C3\\
Z = z - a_1\\
X = \cfrac{x - y} {C1 - S1}\\
\end{cases}
alors :
\begin{cases}
X = k_2 * C2 - k_1 * S2\\
Z = k_1 * C2 + k_2 * S2
\end{cases}
$$</p>
<p>Pour simplifier cette partie là, nous avons laissé à Python le soin de résoudre le système pour nous : </p>
<pre><code class="language-python">eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
theta_2 = math.atan2(sol[S2], sol[C2])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-1"><a class="header" href="#code-1">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 00.0
y = 00.0
z = 300.0

print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 
print(f'Zm = {z}')
print('')

# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0
a3 = 100.0

# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, -A2 * sp.sin(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_2_3 = np.array([[sp.cos(Theta_3), -sp.sin(Theta_3), 0, A3 * sp.cos(Theta_3)],
                        [sp.sin(Theta_3), sp.cos(Theta_3), 0, A3 * sp.sin(Theta_3)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_3 = trans_mat_0_1 @ trans_mat_1_2 @ trans_mat_2_3
#print(f'trans_mat_0_3 = {trans_mat_0_3}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_3[0, 3], x)
eq2 = sp.Eq(trans_mat_0_3[1, 3], y)
eq3 = sp.Eq(trans_mat_0_3[2, 3], z)

sp.simplify(trans_mat_0_3[0, 3])
sp.simplify(trans_mat_0_3[1, 3])
sp.simplify(trans_mat_0_3[2, 3])


# we get theta_1 by doing eqy / eqx
theta_1 = math.atan2(y, x)
theta_1_degree = np.degrees(theta_1)
print(f'theta_1 = {theta_1}')
print(f'theta_1_degree = {theta_1_degree}')

# we get theta3 from X² + Y² + Z² (and using sin(a-b))
S3 = (a1**2 - a2**2 - a3**2 + x**2 + y**2 + z**2 - 2 * a1 * z) / (2 * a2 * a3)
# we then know that cos² + sin² = 1, so we can have two values for C3
C3_pos = np.sqrt(1 - S3**2)
print(f'C3_pos = {C3_pos}')
C3_neg = -np.sqrt(1 - S3**2)
print(f'C3_neg = {C3_neg}')
# We get theta_3 from tan2
theta_3 = math.atan2(S3, C3_pos)
theta_3_bis = math.atan2(S3, C3_neg)#print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3_bis = {np.degrees(theta_3_bis)}')
# Note that both values are possibles positions for the arm

# To get theta_2, we first define some constantes to get simple equations
k1 = a2 + a3 * np.sin(theta_3)
k2 = a3 * np.cos(theta_3)
Z = z - a1
X = (x - y) / (np.cos(theta_1) - np.sin(theta_1))

C2 = sp.symbols('C2')
S2 = sp.symbols('S2')

# We use X and Z equations to get a system with 2 equations and 2 unknown values
# We can then ask the help of Python to get the result (thank you sympy)
eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
print(f'sol = {sol}')
theta_2 = math.atan2(sol[S2], sol[C2])
print(f'theta_2 = {np.degrees(theta_2)}')

print('')
print(f'theta_1 = {np.degrees(theta_1)}')
print(f'theta_2 = {np.degrees(theta_2)}')
print(f'theta_3 = {np.degrees(theta_3)}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-dof-robotic-arm"><a class="header" href="#4-dof-robotic-arm">4 dof robotic arm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-2"><a class="header" href="#code-2">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 30.0
y = 00.0
z = 270.0

print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 
print(f'Zm = {z}')
print('')

# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0
a3 = 100.0
a4 = 30.0
a5 = 50.0


# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
Theta_4 = sp.symbols('Theta_4')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
A4 = sp.symbols('A4')
A5 = sp.symbols('A5')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, -A2 * sp.sin(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_2_3 = np.array([[sp.cos(Theta_3), -sp.sin(Theta_3), 0, A3 * sp.cos(Theta_3)],
                        [sp.sin(Theta_3), sp.cos(Theta_3), 0, A3 * sp.sin(Theta_3)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_3_4 = np.array([[sp.cos(Theta_4), -sp.sin(Theta_4), 0, A4 * sp.cos(Theta_4) - A5 * sp.sin(Theta_4)],
                        [sp.sin(Theta_4), sp.cos(Theta_4), 0, A4 * sp.sin(Theta_4) + A5 * sp.cos(Theta_4)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_4 = trans_mat_0_1 @ trans_mat_1_2 @ trans_mat_2_3 @ trans_mat_3_4
# print(f'trans_mat_0_4 = {trans_mat_0_4}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_4[0, 3], x)
eq2 = sp.Eq(trans_mat_0_4[1, 3], y)
eq3 = sp.Eq(trans_mat_0_4[2, 3], z)

sp.simplify(trans_mat_0_4[0, 3])
sp.simplify(trans_mat_0_4[1, 3])
sp.simplify(trans_mat_0_4[2, 3])

# one equation is very important now. We want that y4 = z0 (see schematics), so the point M is all the time facing up
sp.simplify(trans_mat_0_4[2, 1])



# we get theta_1 by doing eqy / eqx
theta_1 = math.atan2(y, x)
theta_1_degree = np.degrees(theta_1)
print(f'theta_1 = {theta_1}')
print(f'theta_1_degree = {theta_1_degree}')

# We have to make a correction on x and y because of a4 distance that we didn't include during 3 dof study
x = x - a4 * np.cos(theta_1)
y = y - a4 * np.sin(theta_1)
# We also make a correction on z, but through a1 (adding a5)
a1 += a5


# we get theta3 from X² + Y² + Z² (and using sin(a-b))
S3 = (a1**2 - a2**2 - a3**2 + x**2 + y**2 + z**2 - 2 * a1 * z) / (2 * a2 * a3)
# we then know that cos² + sin² = 1, so we can have two values for C3
C3_pos = np.sqrt(1 - S3**2)
print(f'C3_pos = {C3_pos}')
C3_neg = -np.sqrt(1 - S3**2)
print(f'C3_neg = {C3_neg}')
# We get theta_3 from tan2
theta_3 = math.atan2(S3, C3_pos)
theta_3_bis = math.atan2(S3, C3_neg)
print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3_bis = {np.degrees(theta_3_bis)}')
# Note that both values are possibles positions for the arm

# To get theta_1, we first define some constantes to get simple equations
k1 = a2 + a3 * np.sin(theta_3)
k2 = a3 * np.cos(theta_3)
Z = z - a1
X = (x - y) / (np.cos(theta_1) - np.sin(theta_1))

C2 = sp.symbols('C2')
S2 = sp.symbols('S2')

# We use X and Z equations to get a system with 2 equations and 2 unknown values
# We can then ask the help of Python to get the result (thank you sympy)
eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
print(f'sol = {sol}')
theta_2 = math.atan2(sol[S2], sol[C2])
print(f'theta_2 = {np.degrees(theta_2)}')

print('')
print(f'theta_1 = {np.degrees(theta_1)}')
print(f'theta_2 = {np.degrees(theta_2)}')
print(f'theta_3 = {np.degrees(theta_3)}')


# we solve theta_4 by using trans_mat_0_4[2, 1]
# cos(Theta_2 + Theta_3 + Theta_4) = 1
theta_4 = -theta_2 - theta_3 
print(f'theta_4 = {np.degrees(theta_4)}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-dof-robotic-arm"><a class="header" href="#5-dof-robotic-arm">5 dof robotic arm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="méthode-alternative---algorithme-doptimisation"><a class="header" href="#méthode-alternative---algorithme-doptimisation">Méthode alternative - Algorithme d'optimisation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-3"><a class="header" href="#code-3">Code</a></h1>
<p>Fonctions de l'implémentation de <strong>Levenberg-Marquart</strong> et de sa fonction assosiée au problème <a href="./4_dof.html">4 DOF</a>.</p>
<p>En dessous se trouve le code principal.</p>
<pre><code class="language-python">&quot;&quot;&quot;
Date: 2023-03-27
Author: Romain
This script was developed for target positionning with different algorithms.
&quot;&quot;&quot;

import numpy as np

def non_linear_least_squares_functions(pos, joints):
    print(f'{joints}')

    # f(x) returns the residuals
    f = lambda x: np.array([joints[1]*np.cos(x[0]) + joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]) - pos[0],
                joints[0] + joints[1]*np.sin(x[0]) + joints[2]*np.sin(x[0]+x[1]) + joints[3]*np.sin(x[0]+x[1]+x[2]) - pos[2]])
    # Df(x) is the N by 2 derivative matrix
    Df = lambda x: np.array([[-joints[1]*np.sin(x[0]) - joints[2]*np.sin(x[0]+x[1]) - joints[3]*np.sin(x[0]+x[1]+x[2]), -joints[2]*np.sin(x[0]+x[1]) - joints[3]*np.sin(x[0]+x[1]+x[2]), -joints[3]*np.sin(x[0]+x[1]+x[2])],
                             [joints[1]*np.cos(x[0]) + joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]), joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]), joints[3]*np.cos(x[0]+x[1]+x[2])]])
    return f, Df

def levenberg_marquardt(f, Df, x0, lambda0, tol = 1e-2, kmax = 100):
    n = len(x0)
    x = x0
    lam = lambda0
    obj = np.zeros((0,1))
    res = np.zeros((0,1))
    for k in range(kmax):
        obj = np.vstack([obj, np.linalg.norm(f(x))**2])
        res = np.vstack([res, np.linalg.norm(2*Df(x).T @ f(x))])
        if np.linalg.norm(2*Df(x).T @ f(x)) &lt; tol:
            break
        xt = x - np.linalg.inv((Df(x).T @ Df(x)) + lam*np.eye(n)) @ (Df(x).T @ f(x))
        
        # handle 180° limit with 20° marge error (~10%*pi)
        xt[0] = np.clip(xt[0],  0.1 * np.pi, 0.9 * np.pi) #   0° - 180°
        xt[1] = np.clip(xt[1], -0.4 * np.pi, 0.4 * np.pi) # -90° - 90°
        xt[2] = np.clip(xt[2], -0.4 * np.pi, 0.4 * np.pi) # -90° - 90°
                

        if np.linalg.norm(f(xt)) &lt; np.linalg.norm(f(x)) :
            lam = 0.8*lam
            x = xt
        else:
            lam = 2.0*lam
    return x, {'Objective':obj, 'Residual':res}
</code></pre>
<p>Et ici le code principal faisant appel au code précédent.
Ils vous faut mettre votre position x,y,z voulue dans les variables au début du programme.</p>
<pre><code class="language-python">x = message.x
y = message.y
z = message.z

print('received message')
print('Objectif :')
print(f'X = {x}')
print(f'Y = {y}')
print(f'Z = {z}')
print('')

pos = [x, y, z] # vecteur de la position voulue
joints = [a1, a2, a3, a4] # vecteur avec la taille des différentes branches

# Target location using L-M with LLS estimation as starting point and lambda = 0.1
f, Df = lv.non_linear_least_squares_functions(pos, joints)
x_lm, history_lm = lv.levenberg_marquardt(f, Df, [0,0,0], 0.1, 1e-4)

thetas = np.concatenate([np.array([np.arctan2(y,x)*180/np.pi % 360]), np.degrees(x_lm)])
print(f&quot;{thetas}&quot;)        
print(f&quot;{thetas % 360}&quot;)

# I have a problem on theta1 that can be &gt; 180, AND MY SERVO CANNOT
if thetas[0] &gt; 180:
    thetas[0] -= 180
    thetas[1] = 180 - thetas[1]
    thetas[2] = 180 - thetas[2]
    thetas[3] = 180 - thetas[3]


print(f&quot;theta_1 = {thetas[0]}, theta_2 = {thetas[1]}, theta_3 = {thetas[2]}, theta_4 = {thetas[3]} &quot;)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
