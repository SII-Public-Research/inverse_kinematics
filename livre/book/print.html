<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inverse Kinetics</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Methode.html"><strong aria-hidden="true">1.1.</strong> Methode</a></li><li class="chapter-item expanded "><a href="Organisation.html"><strong aria-hidden="true">1.2.</strong> Organisation du répertoire</a></li></ol></li><li class="chapter-item expanded "><a href="2_dof.html"><strong aria-hidden="true">2.</strong> Bras 2 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_2_dof.html"><strong aria-hidden="true">2.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="3_dof.html"><strong aria-hidden="true">3.</strong> Bras 3 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_3_dof.html"><strong aria-hidden="true">3.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="4_dof.html"><strong aria-hidden="true">4.</strong> Bras 4 DdL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_4_dof.html"><strong aria-hidden="true">4.1.</strong> Code</a></li></ol></li><li class="chapter-item expanded "><a href="5_dof.html"><strong aria-hidden="true">5.</strong> Bras 5 DdL</a></li><li class="chapter-item expanded "><a href="levenberg.html"><strong aria-hidden="true">6.</strong> Méthode alternative - Algorithme d'optimisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_4_dof_levenberg.html"><strong aria-hidden="true">6.1.</strong> Code</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Inverse Kinetics</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ce livre a pour but de présenter la démarche expérimentale que nous avons mise en œuvre afin de maîtriser, ou du moins mieux appréhender, les techniques de cinématiques inverses utilisées en robotique. </p>
<p>Le but final étant de pouvoir contrôler de manière précise un bras robotique comprenant 5 degrés de libertés. </p>
<h1 id="outils"><a class="header" href="#outils">Outils</a></h1>
<p>Au sein de notre équipe, nous avons un petit faible pour le langage RUST et son implémentation dans des cibles embarqués. 
Nous avons donc souhaité utiliser ce langage pour la partie embarquée.</p>
<p>Du Python sera utilisé pour tester les approches mathématiques mises en avant afin de rapidement modéliser un système. Les principales librairies utilisées étant <strong>numpy</strong> et <strong>sympy</strong></p>
<p>Enfin, nous créerons un lien entre la commande moteur et les algorithmes en utilisant l’environnement ROS (robot operating system). </p>
<h1 id="matériel"><a class="header" href="#matériel">Matériel</a></h1>
<p>Notre étude se voulant pratique, nous sommes parti sur un bras robotique disponible dans le commerce.</p>
<p>Les différents liens utiles étant :</p>
<ul>
<li><a href="https://www.gotronic.fr/art-bras-robotique-joy-it-robot02-26637.html">Achat</a></li>
<li><a href="https://www.gotronic.fr/pj2-robot02-guide-de-montage-1556.pdf">Montage</a></li>
</ul>
<p>Afin de contrôler le bras, nous avons déterré un vieux shield moteur que nous avions déjà utilisé auparavant, en ajoutant des fonctionnalités de contrôle de servomoteurs.
Les différents liens utiles étant :</p>
<ul>
<li><a href="https://www.makerbuying.com/docs/new-sna41">Présentation</a></li>
<li><a href="https://github.com/SII-Public-Research/sna41-motorshield">crate RUST</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="méthode"><a class="header" href="#méthode">Méthode</a></h1>
<p>Nous décomposerons l'étude du bras final en plusieurs sous-parties, en partant d'un système comprenant 2 degrés de libertés et en en ajoutant un par un jusqu'à atteindre le nombre de degrés de libertés du bras réel. 
Nous espérons ainsi pouvoir identifier à chaque étape les difficultés additionnels liés à chaque ajout. </p>
<p>Pour chaque modèle, nous utiliserons la convention de <a href="https://fr.wikipedia.org/wiki/Denavit-Hartenberg">Denavit-Hartenberg</a> pour visualiser de façon schématique le système. 
Ensuite, nous définirons les matrices de transition pour chaque liaison, même si dans les premiers cas d'étude une approche graphique pourrait amener à une solution plus rapide. </p>
<p>Enfin, nous préciserons pour chaque système une solution, relié à un script python puis une implémentation en Rust sur un système réel.</p>
<h2 id="schéma-cinématique"><a class="header" href="#schéma-cinématique">Schéma cinématique</a></h2>
<p><em>Pour simplifier au maximum le système visuellement</em></p>
<p>Nous choisirons de respecter les conventions de <strong>Denavit-Hartenberg</strong> afin de schématiser nos sysèmes et de positionner des repères sur chaque liaison.</p>
<h2 id="matrices-de-transition"><a class="header" href="#matrices-de-transition">Matrices de transition</a></h2>
<p><em>Pour découper le problème et représenter mathématiquement chaque liaison</em></p>
<p>exemple : </p>
<p><img src="images/matriceTransition.png" alt="matriceTransition" /></p>
<p>Elle est composée d'une <strong>matrice d'orientaiton</strong> 3x3 qui représente le changement de repère effectué au niveau d'une liaison parfaite (ici, nous aurons affaire uniquement à des liaisons pivots), et d'un <strong>vecteur de position</strong> qui représente le changement de repère d'un point d'interêt de notre système (point commun entre deux liaisons ou point final à positionner)</p>
<h2 id="matrice-caractéristique"><a class="header" href="#matrice-caractéristique">Matrice caractéristique</a></h2>
<p><em>pour rassembler les petits problèmes et représenter le système complet</em></p>
<p>Cette matrice est obtenue en faisant en multipliants toutes les matrices obtenues. </p>
<h2 id="cinématique-normale"><a class="header" href="#cinématique-normale">Cinématique normale</a></h2>
<p><em>Calcule la position du bras suivant les angles des liaisons</em></p>
<h2 id="cinématique-inverse"><a class="header" href="#cinématique-inverse">Cinématique inverse</a></h2>
<p><em>Calcule les angles des liaisons suivant la position du bras</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation-du-répertoire"><a class="header" href="#organisation-du-répertoire">Organisation du répertoire</a></h1>
<p>Le répertoire est composé de 2 dossiers principaux. </p>
<p>Chaque système sera étudié mathématiquement dans la partie 'livre' et aura une implémentation concrète dans le dossier ''exemples''.</p>
<h2 id="livre"><a class="header" href="#livre"><strong>livre</strong></a></h2>
<p><em>Créé à partir du template <a href="https://rust-lang.github.io/mdBook/index.html">md-book</a> fourni par la crate Rust du même nom.</em></p>
<p>Vous pouvez lancer la lecture du livre via la commande suivante :</p>
<pre><code class="language-bash">mdbook build --open
</code></pre>
<h2 id="exemples"><a class="header" href="#exemples"><strong>exemples</strong></a></h2>
<p><em>Comprend l’environnement prêt à être déployé sur une raspberry pi. Nous vous invitons à vous renseigner sur l'utilisation de <a href="https://docs.ros.org/en/humble/index.html">ROS2</a> avant d'utiliser cette partie.</em></p>
<p>Le programme est divisé en deux packages :</p>
<ul>
<li><strong>command</strong> : c'est la partie algorithmie, qui prendra en entrée un message de type <em>geometry_msgs/msg/Point</em> pour le transformer en message de type <em>messages/msg/MotorsAngles</em>.</li>
<li><strong>motors_ctr</strong> : c'est la partie contrôle des moteurs qui prendra en entré un message de type <em>messages/msg/MotorsAngles</em> afin de le transformer en commande moteurs.</li>
</ul>
<p>Vous pourrez retrouver deux parties dans ces exemples :</p>
<ul>
<li><strong>classique</strong> : Pour les études de cinématiques utilisants la méthode la plus conramment utilisée.</li>
<li><strong>levenberg</strong> : Pour l'utilisation d'algorithmes d'optimisation pour résoudre le système. </li>
</ul>
<p>Vous devrez dans un premier temps compiler le programme :</p>
<pre><code class="language-bash">cd exemples/classique
colcon build
</code></pre>
<p>Une fois réalisé, il est important de sourcer les exécutables générés afin que ROS puisse les retrouver.</p>
<pre><code class="language-bash">. install/setup.bash
</code></pre>
<p>Vous pouvez utiliser le ficher .launch qui permet de lancer les deux nodes utilisées dans le processus de contrôle du bras. </p>
<pre><code class="language-bash">ros2 launch $exemple_name.py
</code></pre>
<p>Enfin, vous devrez utiliser un autre terminal afin d'envoyer une commande de type <em>geometry_msgs/msg/Point</em> et ainsi contrôler le bras en position. </p>
<pre><code class="language-bash">ros2 topic pub --once /cmd_arm geometry_msgs/msg/Point &quot;{x = 0.0, y = 0.0, z = 200.0}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-dof-robotic-arm"><a class="header" href="#2-dof-robotic-arm">2 dof robotic arm</a></h1>
<p>Commençons par monter uniquement deux servomoteurs sur notre bras.</p>
<h2 id="schéma-cinématique-1"><a class="header" href="#schéma-cinématique-1">Schéma cinématique</a></h2>
<p><img src="images/2dof_luna_arm.drawio.png" alt="schema_2dof" /></p>
<h2 id="matrices-de-transition-1"><a class="header" href="#matrices-de-transition-1">Matrices de transition</a></h2>
<p>Une fois le schéma déssiné, il est possible de découper le problème en plus petites étapes. Chaque matrice de transition représente les rotations et transitions d'une liaison. 
Une fois la position initiale du robot choisie, ici un angle de 90° entre le segment <strong>OA</strong> et <strong>AM</strong>, nous pouvons écrire les matrices de transitions correspondantes :</p>
<p>$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; 0 &amp; S1 &amp; 0\\
S1 &amp; 0 &amp; -C1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; -S2 &amp; 0 &amp; a_2C2\\
S2 &amp; C2 &amp; 0 &amp; a_2S2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Avec $$ S1 = sin(θ_1), S2 = sin(θ_2), C1 = cos(θ_1), C2 = cos(θ_2) $$</p>
<h2 id="matrice-caractéristique-1"><a class="header" href="#matrice-caractéristique-1">Matrice caractéristique</a></h2>
<p>Une fois les matrices de transitions pour chaque liaisons réalisés, nous pouvons faire leur produit matriciel afin d'obtenir la matrice caractéristique du système étudié. </p>
<p>$$
T02 = 
\left(\begin{array}{cc}
C1C2 &amp; -C1S2 &amp; S1 &amp; a_2C1C2\\
S1C2 &amp; -S1S2 &amp; -C1 &amp; a_2S1C2\\
S2 &amp; C2 &amp; 0 &amp; a_1 + a_2S2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<h2 id="cinématique-normale-1"><a class="header" href="#cinématique-normale-1">Cinématique normale</a></h2>
<p>Dans ce cas précis, avec uniquement deux liaisons, le système est relativement simple et nous pouvons nous contenter d'utiliser la dernière colonne de la matrice qui représente les équations de la position finale du bras en fonction des angles des moteurs. Ces équations représentent à quelle position <strong>(x,y,z)</strong> le bout du bras est, connaissant les angles <strong>θ<sub>1</sub></strong> et <strong>θ<sub>2</sub></strong>. </p>
<p>$$ 
\begin{cases}
x = a_2 * cos(θ_1) * cos(θ_2) \\
y = a_2 * sin(θ_1) * cos(θ_2) \\
z = a_1 + a_2 * sin(θ_2)
\end{cases}
$$</p>
<p>C'est la cinématique du système. Cependant nous recherchons l'inverse : quels angles <strong>θ<sub>1</sub></strong> et <strong>θ<sub>2</sub></strong> prendre pour que le bras aille à la position <strong>(x,y,z)</strong> voulue.</p>
<h2 id="cinématique-inverse-1"><a class="header" href="#cinématique-inverse-1">Cinématique inverse</a></h2>
<h3 id="θ1"><a class="header" href="#θ1">θ<sub>1</sub></a></h3>
<p>Pour <strong>θ<sub>1</sub></strong>, nous pouvons calculer son sinus et son cosinus à partir des équations de Y et X :
$$
\begin{cases}
sin(θ_1)  = \cfrac{y}{a_2 * cos(θ_2)}\\
cos(θ_1) = \cfrac{x}{a_2 * cos(θ_2)}
\end{cases}
$$</p>
<p>on obtient ainsi <strong>θ<sub>1</sub></strong> en faisant le calcul eq(y) / eq(x) :</p>
<p>$$
θ_1 = atan2(\cfrac{y}{x})
$$</p>
<h3 id="θ2"><a class="header" href="#θ2">θ<sub>2</sub></a></h3>
<p>Pour <strong>θ<sub>2</sub></strong>, nous pouvons calculer son sinus et son cosinus à partir des équations de Z et X (ou Y) :
$$
\begin{cases}
sin(θ_2) = \cfrac{z - a_1}{a_2}\\
cos(θ_2) = \cfrac{x}{a_2 * cos(θ_1)}
\end{cases}
$$</p>
<p>Enfin, nous pouvons obtenir l'angle <strong>θ<sub>2</sub></strong> de la même manière que <strong>θ<sub>1</sub></strong> :</p>
<p>$$
θ_2 = atan2(\cfrac{(z - a_1) * cos(θ_1)}{x})
$$</p>
<h2 id="conclusion-et-amélioration"><a class="header" href="#conclusion-et-amélioration">Conclusion et amélioration</a></h2>
<p>Nous pouvons observer qu'il est relativement facile dans le cas de deux liaisons d'obtenir une cinématique inverse du système. </p>
<p>En revanche, le système est limité et ne peut atteindre qu'un champ réduit de points, correspondant à une sphère de rayon a2. 
Nous notons également que dans notre cas d'étude, les servomoteurs ont une portée comprise entre 0 et 180°.</p>
<p>Afin de rendre le programme utilisable facilement, nous avons donc prévu une correction de la commande en Z, qui sera calculé à partir des paramètres d'entrés (X, Y). Cela évite de devoir calculer précisément une position du bras pour obtenir un déplacement réalisable. </p>
<p>$$
z = \sqrt{a_2^2 - x^2 - y^2} + a_1
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code"><a class="header" href="#code">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene, romain.saboret
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 0.0
y = 0.0
z = 190.0
print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 


# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0

# We first check if the command is a possible input. If not, we change the z target
z = np.sqrt(a2**2 - x**2 - y**2) + a1
print(f'Zm = {z}')
print('')

# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.sin(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_2 = trans_mat_0_1 @ trans_mat_1_2
#print(f'trans_mat_0_2 = {trans_mat_0_2}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_2[0, 3], x)
eq2 = sp.Eq(trans_mat_0_2[1, 3], y)
eq3 = sp.Eq(trans_mat_0_2[2, 3], z)

sp.simplify(trans_mat_0_2[0, 3])
sp.simplify(trans_mat_0_2[1, 3])
sp.simplify(trans_mat_0_2[2, 3])

# we get theta_1 by doing eqy / eqx
theta_1 = math.atan2(y, x)
theta_1_degree = np.degrees(theta_1)
print(f'theta_1 = {theta_1}')
print(f'theta_1_degree = {theta_1_degree}')

# We can have S2 with Z eq
S2 = (z - a1) / a2
# Then, we can get 2 values for C2 according to eq cos² + sin² = 1
C2_pos = np.sqrt(1 - S2**2)
C2_neg = -np.sqrt(1 - S2**2)
# Finally, we got theta_2 from atan2
theta_2 = math.atan2(S2, C2_pos)
theta_2_bis = math.atan2(S2, C2_neg)
print(f'theta_2 = {np.mod(np.degrees(theta_2), 360)}')
print(f'theta_2_bis = {np.mod(np.degrees(theta_2_bis), 360)}')
# Note that we have two possible values for theta_2. 
# We noticed that the first one is all the time working fine on our case
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3_dof-robotic-arm"><a class="header" href="#3_dof-robotic-arm">3_dof robotic arm</a></h1>
<p>Ajoutons un servo-moteur à notre bras. 
Nous obtenons ainsi un système comprenant 3 degrés de libertés. </p>
<h2 id="schéma-cinématique-2"><a class="header" href="#schéma-cinématique-2">Schéma cinématique</a></h2>
<p><img src="images/3dof_luna_arm.drawio.png" alt="schema_3dof" /></p>
<h2 id="matrices-de-transition-2"><a class="header" href="#matrices-de-transition-2">Matrices de transition</a></h2>
<p>Nous choisissons pour cette étude de changer la position initiale entre le segment <strong>OA</strong> et <strong>AB</strong>, que nous fixons à 180°. Pour la position initiale du 3ème moteur, nous choisissons un angle de 90° entre le segment <strong>AB</strong> et <strong>BM</strong>. Nous pouvons ainsi écrire les matrices de transitions correspondantes :</p>
<p>$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; 0 &amp; S1 &amp; 0\\
S1 &amp; 0 &amp; -C1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; -S2 &amp; 0 &amp; -a_2S2\\
S2 &amp; C2 &amp; 0 &amp; a_2C2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T23 = 
\left(\begin{array}{cc}
C3 &amp; -S3 &amp; 0 &amp; a_3C3\\
S3 &amp; C3 &amp; 0 &amp; a_3S3\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<h2 id="matrice-caractéristique-2"><a class="header" href="#matrice-caractéristique-2">Matrice caractéristique</a></h2>
<p>La matrice représentative du système est alors plus complexe, et l'on commence à distinguer quelques difficultés à trouver une solution simple au système : </p>
<p>$$
T03 = 
\left(\begin{array}{cc}
C1(C2C3 - S2S3) &amp; -C1(S2C3 + C2S3) &amp; S1 &amp; C1(-a_2S2 + a_3C23)\\
S1(C2C3 - S2S3) &amp; -S1(S2C3 + C2S3) &amp; -C1 &amp; S1(-a_2S2 + a_3C23)\\
S2C3 + S3C2 &amp; -S2S3 + C2C3 &amp; 0 &amp; a_1 + a_2C2 + a_3S23\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<h2 id="cinématique-normale-2"><a class="header" href="#cinématique-normale-2">Cinématique normale</a></h2>
<p>Cependant, en utilisant toujours uniquement les équations sur (X, Y, Z), on obtient un système à 3 équations et 3 inconnues qu'il est possible de résoudre. </p>
<p>$$ 
\begin{cases}
x = cos(θ_1)(-a_2 * sin(θ_2) + a_3 * cos(θ_2 + θ_3)) \\
y = sin(θ_1)(-a_2 * sin(θ_2) + a_3 * cos(θ_2 + θ_3))\\
z = a_1 + a_2 * sin(θ_2)
\end{cases}
$$</p>
<h2 id="cinématique-inverse-2"><a class="header" href="#cinématique-inverse-2">Cinématique inverse</a></h2>
<h3 id="θ1-1"><a class="header" href="#θ1-1">θ<sub>1</sub></a></h3>
<p>En effet, on constate qu'il est facile d'obtenir <strong>θ<sub>1</sub></strong>, en utilisant la même méthode que pour le bras 2ddl :
$$
θ_1 = atan2(\cfrac{y}{x})
$$</p>
<h3 id="θ3"><a class="header" href="#θ3">θ<sub>3</sub></a></h3>
<p>Ensuite, <strong>sin(θ<sub>3</sub>)</strong> est obtenu en faisant la somme des trois équations misent au carré, et en utilisant les propriétés du sinus sin(a-b) :
$$
sin(θ_3) = \cfrac{a_1^2 - a_2^2 - a_3^2 + x^2 + y^2 + z^2 - 2 * a_1 * z} {2 * a_2 * a_3}
$$</p>
<p>On récupère ensuite la valeur de <strong>cos(θ<sub>3</sub>)</strong> en utilisant la propriété <strong>cos² + sin² = 1</strong>
$$
C3 = ±\sqrt{1 - S3^2}
$$
On peut noter que l'on aura deux valeurs possibles de <strong>θ<sub>3</sub></strong>, qui correspondront à deux configurations possibles du bras. 
$$
θ_3 = atan2(\cfrac{S3}{C3})
$$</p>
<h3 id="θ2-1"><a class="header" href="#θ2-1">θ<sub>2</sub></a></h3>
<p>Une fois <strong>θ<sub>1</sub></strong> et <strong>θ<sub>3</sub></strong> obtenus, il est alors possible, en simplifiant les équations, de retrouver un système à deux équations et 2 inconnues (C2 et S2)
$$
soit :
\begin{cases}
k_1 = a_2 + a_3 * S3\\
k_2 = a_3 * C3\\
Z = z - a_1\\
X = \cfrac{x - y} {C1 - S1}\\
\end{cases}
alors :
\begin{cases}
X = k_2 * C2 - k_1 * S2\\
Z = k_1 * C2 + k_2 * S2
\end{cases}
$$</p>
<p>Pour simplifier cette partie là, nous avons laissé à Python le soin de résoudre le système pour nous : </p>
<pre><code class="language-python">eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
theta_2 = math.atan2(sol[S2], sol[C2])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-1"><a class="header" href="#code-1">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 00.0
y = 00.0
z = 300.0

print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 
print(f'Zm = {z}')
print('')

# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0
a3 = 100.0

# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, -A2 * sp.sin(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_2_3 = np.array([[sp.cos(Theta_3), -sp.sin(Theta_3), 0, A3 * sp.cos(Theta_3)],
                        [sp.sin(Theta_3), sp.cos(Theta_3), 0, A3 * sp.sin(Theta_3)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_3 = trans_mat_0_1 @ trans_mat_1_2 @ trans_mat_2_3
#print(f'trans_mat_0_3 = {trans_mat_0_3}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_3[0, 3], x)
eq2 = sp.Eq(trans_mat_0_3[1, 3], y)
eq3 = sp.Eq(trans_mat_0_3[2, 3], z)

sp.simplify(trans_mat_0_3[0, 3])
sp.simplify(trans_mat_0_3[1, 3])
sp.simplify(trans_mat_0_3[2, 3])


# we get theta_1 by doing eqy / eqx
theta_1 = math.atan2(y, x)
theta_1_degree = np.degrees(theta_1)
print(f'theta_1 = {theta_1}')
print(f'theta_1_degree = {theta_1_degree}')

# we get theta3 from X² + Y² + Z² (and using sin(a-b))
S3 = (a1**2 - a2**2 - a3**2 + x**2 + y**2 + z**2 - 2 * a1 * z) / (2 * a2 * a3)
# we then know that cos² + sin² = 1, so we can have two values for C3
C3_pos = np.sqrt(1 - S3**2)
print(f'C3_pos = {C3_pos}')
C3_neg = -np.sqrt(1 - S3**2)
print(f'C3_neg = {C3_neg}')
# We get theta_3 from tan2
theta_3 = math.atan2(S3, C3_pos)
theta_3_bis = math.atan2(S3, C3_neg)#print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3_bis = {np.degrees(theta_3_bis)}')
# Note that both values are possibles positions for the arm

# To get theta_2, we first define some constantes to get simple equations
k1 = a2 + a3 * np.sin(theta_3)
k2 = a3 * np.cos(theta_3)
Z = z - a1
X = (x - y) / (np.cos(theta_1) - np.sin(theta_1))

C2 = sp.symbols('C2')
S2 = sp.symbols('S2')

# We use X and Z equations to get a system with 2 equations and 2 unknown values
# We can then ask the help of Python to get the result (thank you sympy)
eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
print(f'sol = {sol}')
theta_2 = math.atan2(sol[S2], sol[C2])
print(f'theta_2 = {np.degrees(theta_2)}')

print('')
print(f'theta_1 = {np.degrees(theta_1)}')
print(f'theta_2 = {np.degrees(theta_2)}')
print(f'theta_3 = {np.degrees(theta_3)}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-dof-robotic-arm"><a class="header" href="#4-dof-robotic-arm">4 dof robotic arm</a></h1>
<p>Ajoutons un servo-moteur à notre bras. 
Nous obtenons ainsi un système comprenant 4 degrés de libertés. </p>
<h2 id="schéma-cinématique-3"><a class="header" href="#schéma-cinématique-3">Schéma cinématique</a></h2>
<p><img src="images/4dof_luna_arm.drawio.png" alt="schema_4dof" /></p>
<h2 id="matrices-de-transition-3"><a class="header" href="#matrices-de-transition-3">Matrices de transition</a></h2>
<p>La position initiale du 4ème moteur est fixée dans le même axe que le moteur précedent.</p>
<p>$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; 0 &amp; S1 &amp; 0\\
S1 &amp; 0 &amp; -C1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; -S2 &amp; 0 &amp; -a_2S2\\
S2 &amp; C2 &amp; 0 &amp; a_2C2\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T23 = 
\left(\begin{array}{cc}
C3 &amp; -S3 &amp; 0 &amp; a_3C3\\
S3 &amp; C3 &amp; 0 &amp; a_3S3\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>$$
T34 = 
\left(\begin{array}{cc}
C4&amp; -S4 &amp; 0 &amp; a_4C4 - a_5S4\\
S4 &amp; C4 &amp; 0 &amp; a_4S4 + a_5C4\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<h2 id="matrice-caractéristique-3"><a class="header" href="#matrice-caractéristique-3">Matrice caractéristique</a></h2>
<p>La matrice représentative du système est la suivante :</p>
<p>$$
T04 = 
\left(\begin{array}{cc}
C1C234 &amp; -C1S234 &amp; S1 &amp; C1(-a_2S2 + a_3C23 + a_4C234 - a_5S234)\\
S1C234 &amp; -S234 &amp; -C1 &amp; S1(-a_2S2 + a_3C23 + a_4C234 - a_5S234)\\
S234 &amp; C234 &amp; 0 &amp; a_1 + a_2C2 + a_3S23 + a_4S234 + a_5C234\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Si nous continuons à utiliser uniquement le vecteur Position, nous nous retrouvons avec un système à 4 inconnues pour 3 équations. 
Nous avons donc besoin de caractériser notre système à l'aide de nouvelles équations.
Nous allons donc piocher dans la matrice d'orientation afin de fixer certaines de nos inconnues et ainsi fixer une orientation du dernier élement de notre système. 
Pour notre cas d'étude, nous allons choisir d'orienter le dernier segment <strong>[CM]</strong> vers le haut. 
Cela revient à :</p>
<p>$$
z_0 = y_4
$$</p>
<p>L'équation qui régit cette égalité est celle présente en coordonnée [2, 1] de la matrice de rotation. Nous devons donc faire en sorte que cette équation soit égale à 1 pour satisfaire notre exigence :</p>
<p>$$
sin(θ_2 + θ_3 + θ_4) = 1
$$</p>
<p>Une fois ce choix effectué, nous pouvons découper notre système en deux partie :</p>
<ul>
<li>les <strong>3 premiers joints</strong> déterminerons le positionnement du bras</li>
<li>le <strong>4eme joint</strong> déterminera l'orientation </li>
</ul>
<p>Pour le positionnement, nous pouvons donc à nouveau utiliser les calculs effectués lors de l'étude du système à 3 servomoteurs, en ajustant tout de même les données de distance afin d'inclure la suite du bras :</p>
<p>$$ 
\begin{cases}
x = x - a_4 * cos(θ_1) \\
y = y - a_4 * sin(θ_1)\\
a_1 = a_1 + a_5
\end{cases}
$$</p>
<p>Une fois ces calculs effectués, nous pouvons calculer la valeure de θ_4 à partir de la matrice de transition[2, 1] :</p>
<p>$$ 
\begin{cases}
θ_4 = -θ_2 - θ_3 
\end{cases}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-2"><a class="header" href="#code-2">Code</a></h1>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Wed Mar 22 09:34:49 2023

@author: clement.pene
&quot;&quot;&quot;

import numpy as np
import sympy as sp
import math

# Here we input the goal target (mm)
x = 30.0
y = 00.0
z = 270.0

print('Objectif :')
print(f'Xm = {x}') 
print(f'Ym = {y}') 
print(f'Zm = {z}')
print('')

# Here we define all the constants we have on the arm
a1 = 85.0
a2 = 105.0
a3 = 100.0
a4 = 30.0
a5 = 50.0


# we want to use the transition matrix to get equations 
Theta_1 = sp.symbols('Theta_1')
Theta_2 = sp.symbols('Theta_2')
Theta_3 = sp.symbols('Theta_3')
Theta_4 = sp.symbols('Theta_4')
A1 = sp.symbols('A1')
A2 = sp.symbols('A2')
A3 = sp.symbols('A3')
A4 = sp.symbols('A4')
A5 = sp.symbols('A5')
X = sp.symbols('X')
Y = sp.symbols('Y')
Z = sp.symbols('Z')


trans_mat_0_1 = np.array([[sp.cos(Theta_1), 0, sp.sin(Theta_1), 0],
                        [sp.sin(Theta_1), 0, -sp.cos(Theta_1), 0],
                        [0, 1, 0, A1],
                        [0, 0, 0, 1]])
trans_mat_1_2 = np.array([[sp.cos(Theta_2), -sp.sin(Theta_2), 0, -A2 * sp.sin(Theta_2)],
                        [sp.sin(Theta_2), sp.cos(Theta_2), 0, A2 * sp.cos(Theta_2)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_2_3 = np.array([[sp.cos(Theta_3), -sp.sin(Theta_3), 0, A3 * sp.cos(Theta_3)],
                        [sp.sin(Theta_3), sp.cos(Theta_3), 0, A3 * sp.sin(Theta_3)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
trans_mat_3_4 = np.array([[sp.cos(Theta_4), -sp.sin(Theta_4), 0, A4 * sp.cos(Theta_4) - A5 * sp.sin(Theta_4)],
                        [sp.sin(Theta_4), sp.cos(Theta_4), 0, A4 * sp.sin(Theta_4) + A5 * sp.cos(Theta_4)],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

trans_mat_0_4 = trans_mat_0_1 @ trans_mat_1_2 @ trans_mat_2_3 @ trans_mat_3_4
# print(f'trans_mat_0_4 = {trans_mat_0_4}')


# I separate equation for (x, y, z) mostly to be able to simplify them after
eq1 = sp.Eq(trans_mat_0_4[0, 3], x)
eq2 = sp.Eq(trans_mat_0_4[1, 3], y)
eq3 = sp.Eq(trans_mat_0_4[2, 3], z)

sp.simplify(trans_mat_0_4[0, 3])
sp.simplify(trans_mat_0_4[1, 3])
sp.simplify(trans_mat_0_4[2, 3])

# one equation is very important now. We want that y4 = z0 (see schematics), so the point M is all the time facing up
sp.simplify(trans_mat_0_4[2, 1])



# we get theta_1 by doing eqy / eqx
theta_1 = math.atan2(y, x)
theta_1_degree = np.degrees(theta_1)
print(f'theta_1 = {theta_1}')
print(f'theta_1_degree = {theta_1_degree}')

# We have to make a correction on x and y because of a4 distance that we didn't include during 3 dof study
x = x - a4 * np.cos(theta_1)
y = y - a4 * np.sin(theta_1)
# We also make a correction on z, but through a1 (adding a5)
a1 += a5


# we get theta3 from X² + Y² + Z² (and using sin(a-b))
S3 = (a1**2 - a2**2 - a3**2 + x**2 + y**2 + z**2 - 2 * a1 * z) / (2 * a2 * a3)
# we then know that cos² + sin² = 1, so we can have two values for C3
C3_pos = np.sqrt(1 - S3**2)
print(f'C3_pos = {C3_pos}')
C3_neg = -np.sqrt(1 - S3**2)
print(f'C3_neg = {C3_neg}')
# We get theta_3 from tan2
theta_3 = math.atan2(S3, C3_pos)
theta_3_bis = math.atan2(S3, C3_neg)
print(f'theta_3 = {np.degrees(theta_3)}')
print(f'theta_3_bis = {np.degrees(theta_3_bis)}')
# Note that both values are possibles positions for the arm

# To get theta_1, we first define some constantes to get simple equations
k1 = a2 + a3 * np.sin(theta_3)
k2 = a3 * np.cos(theta_3)
Z = z - a1
X = (x - y) / (np.cos(theta_1) - np.sin(theta_1))

C2 = sp.symbols('C2')
S2 = sp.symbols('S2')

# We use X and Z equations to get a system with 2 equations and 2 unknown values
# We can then ask the help of Python to get the result (thank you sympy)
eq1 = sp.Eq(k2 * C2 - k1 * S2, X)
eq2 = sp.Eq(k1 * C2 + k2 * S2, Z)
eq = [eq1, eq2]

sol = sp.solve(eq, C2, S2)
print(f'sol = {sol}')
theta_2 = math.atan2(sol[S2], sol[C2])
print(f'theta_2 = {np.degrees(theta_2)}')

print('')
print(f'theta_1 = {np.degrees(theta_1)}')
print(f'theta_2 = {np.degrees(theta_2)}')
print(f'theta_3 = {np.degrees(theta_3)}')


# we solve theta_4 by using trans_mat_0_4[2, 1]
# cos(Theta_2 + Theta_3 + Theta_4) = 1
theta_4 = -theta_2 - theta_3 
print(f'theta_4 = {np.degrees(theta_4)}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-dof-robotic-arm"><a class="header" href="#5-dof-robotic-arm">5 dof robotic arm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="méthode-alternative---algorithme-doptimisation"><a class="header" href="#méthode-alternative---algorithme-doptimisation">Méthode alternative - Algorithme d'optimisation</a></h1>
<p>Pour ce chapitre la méthode change aprés la cinématique :</p>
<ul>
<li>Schéma cinématique <em>pour simplifier au maximum le système visuellement</em></li>
<li>Matrices de transition <em>pour découper le problème et représenter mathématiquement chaque liaison</em></li>
<li>Matrice caractéristique <em>pour rassembler les petits problèmes et représenter le système complet</em></li>
<li>Cinématique normale <em>qui décrit la position du bras suivant les angles des liaisons</em></li>
<li><strong>Equation à minimiser</strong> <em>à définir afin que notre système ait un objectif</em></li>
<li><strong>Matrice jacobienne</strong> <em>à calculer pour obtenir les dérivées partielles de l'équation</em></li>
<li><strong>Levenberg-Marquart</strong> <em>est l'algorithme itératif qui trouvera la solution</em></li>
</ul>
<p>Dans cette partie, nous allons nous concentrer sur une autre méthode pour la cinématique inverse, en réfléchissant différemment. Cette méthode est utilisable peut importe votre nombre de liaisons et vos restrictions. Cependant cette méthode n'est pas géométrique et nécessitera plusieurs itérations pour obtenir les angles voulus.</p>
<p>Le cas étudié sera le même que pour le <a href="./4_dof.html">4 DOF</a>, mais vous pouvez appliquer cette méthode pour les autres cas.</p>
<h2 id="schéma-cinématique-4"><a class="header" href="#schéma-cinématique-4">Schéma cinématique</a></h2>
<p>On ne va pas échapper aux premières étapes nous amenant jusqu'aux équations de cinématique. Même si nous utilisons le cas du <a href="./4_dof.html">4 DOF</a> et que nous pouvons réutiliser leurs équations, nous vous proposont ici de faire un nouveau schéma qui permet de voir le système d'une autre approche.</p>
<h3 id="θ1-2"><a class="header" href="#θ1-2">θ<sub>1</sub></a></h3>
<p>Avec une vue du dessus, nous pouvons voir très simplement quelle équation nous devons choisir pour <strong>θ<sub>1</sub></strong> dans le cas spécifique de notre robot :<br />
<img src="./images/4dof_levenberg_topview.drawio.png" alt="levenberg_top" /></p>
<p>Ainsi nous voyons que l'angle <strong>θ<sub>1</sub></strong> est la seule liaison permettant de bouger sur le plan <strong>(x,y)</strong>. Nous pouvons directement faire de la cinématique inverse et conclure pour <strong>θ<sub>1</sub></strong> :</p>
<p>$$
θ_1 = atan2(\cfrac{y}{x})
$$</p>
<h2 id="matrices-de-transition-4"><a class="header" href="#matrices-de-transition-4">Matrices de transition</a></h2>
<p>Nous pouvons aussi représenter la matrice de transition <strong>T01</strong> que nous pouvons déduire depuis le schéma ci-dessus :<br />
$$
T01 = 
\left(\begin{array}{cc}
C1 &amp; -S1 &amp; 0 &amp; 0\\
S1 &amp; C1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; a_1\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>Après voir fini cela, nous pouvons nous attaquer au reste du système en ignorant l'impact de <strong>θ<sub>1</sub></strong>. En faisant un schéma de profil, nous pouvons voir que les trois liaisons suivantes sont identiques :<br />
<img src="./images/4dof_levenberg_sideview.drawio.png" alt="levenberg_top" /></p>
<p>Comme nos liaisons sont identiques, nos matrices de transitions le sont aussi :
$$
T12 = 
\left(\begin{array}{cc}
C2 &amp; 0 &amp; -S2 &amp; a_2C2\\
0 &amp; 1 &amp; 0 &amp; 0\\
S2 &amp; 0 &amp; C2 &amp; a_2S2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$
$$
T23 = 
\left(\begin{array}{cc}
C3 &amp; 0 &amp; -S3 &amp; a_3C3\\
0 &amp; 1 &amp; 0 &amp; 0\\
S3 &amp; 0 &amp; C3 &amp; a_3S3\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
T34 = 
\left(\begin{array}{cc}
C4 &amp; 0 &amp; -S4 &amp; a_4C4\\
0 &amp; 1 &amp; 0 &amp; 0\\
S4 &amp; 0 &amp; C4 &amp; a_4S4\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<h2 id="matrice-caractéristique-4"><a class="header" href="#matrice-caractéristique-4">Matrice caractéristique</a></h2>
<p>En mutipliant <strong>T01*T12*T23*T34 = T04</strong> on obtient la matrice caractéritique du système :
$$
T04 =
\left(\begin{array}{cc}
? &amp; ? &amp; ? &amp; C1(a_2C2 + a_3C23+a_4C234)\\
? &amp; ? &amp; ? &amp; S1(a_2C2 + a_3C23+a_4C234)\\
? &amp; ? &amp; ? &amp; a_1 + a_2S2 + a_3S23 + a_4S234\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</p>
<p>avec  $$ C234 = cos(θ_2+θ_3+θ_4), S234 = sin(θ_2+θ_3+θ_4) $$</p>
<h2 id="cinématique-normale-3"><a class="header" href="#cinématique-normale-3">Cinématique normale</a></h2>
<p>Nous pouvons donc écrire les équations de cinématique :<br />
$$ 
\begin{cases}
x = cos(θ_1)*(a_2*cos(θ_2)+a_3*cos(θ_2+θ_3+θ_4))\\
y = sin(θ_1)*(a_2*cos(θ_2)+a_3*cos(θ_2+θ_3+θ_4))\\
z = a_1 + a_2*sin(θ_2) + a_3*sin(θ_2+θ_3) + a_4*sin(θ_2+θ_3+θ_4)
\end{cases}
$$</p>
<h2 id="equation-à-minimiser"><a class="header" href="#equation-à-minimiser">Equation à minimiser</a></h2>
<p>Pour trouver quels angles nous devons choisir pour atteindre une certaine position <strong>(x,y,z)</strong> nous devons définir une équation qui, si minimale, alors confirme que les angles sont bons. Pour cela nous allons utiliser les équations de cinématique. Afin de minimiser la taille des matrices qui vont arriver, nous allons simplifier ces équations pour passer de 3 à 2 équations :<br />
$$ 
\begin{cases}
\sqrt{x^{2}+y^{2}} = a_2*cos(θ_2)+a_3*cos(θ_2+θ_3+θ_4)\\
z = a_1 + a_2*sin(θ_2) + a_3*sin(θ_2+θ_3) + a_4*sin(θ_2+θ_3+θ_4)
\end{cases}<br />
$$
$$
\begin{cases}
0 = a_2*cos(θ_2)+a_3*cos(θ_2+θ_3+θ_4)-\sqrt{x^{2}+y^{2}}\\
0 = a_1 + a_2*sin(θ_2) + a_3*sin(θ_2+θ_3) + a_4*sin(θ_2+θ_3+θ_4)-z
\end{cases}
$$</p>
<p>Ici nos équations montrent la différence entre la positions voulue <strong>(x,y,z)</strong> et la position calculée à partir des angles. Si cette différence est égale à zéro, alors les angles choisis permettront d'arriver à la position voulue.
On définit donc la fonction à minimiser :
$$
F(θ_2,θ_3,θ_4) = 
\begin{cases}
a_2*cos(θ_2)+a_3*cos(θ_2+θ_3+θ_4)-\sqrt{x^{2}+y^{2}}\\
a_1 + a_2*sin(θ_2) + a_3*sin(θ_2+θ_3) + a_4*sin(θ_2+θ_3+θ_4)-z
\end{cases}
$$</p>
<h2 id="matrice-jacobienne"><a class="header" href="#matrice-jacobienne">Matrice jacobienne</a></h2>
<p>Nous devons alors calculer la matrice jacobienne associée à cette fonction. C'est donc la matrice des dérivées partielles de la fonction. Dans notre cas cela sera une matrice 2*3 car nous avons deux équations et 3 variables <strong>(θ<sub>2</sub>,θ<sub>3</sub>,θ<sub>4</sub>)</strong> cependant si vous avez gardé les 3 équations de la cinématique, vous aurez une matrice 3*3.
$$
J(F(θ_2,θ_3,θ_4)) = 
\left(\begin{array}{cc}
-a_2S2-a_3S23-a_4S234 &amp; -a_3S23-a_4S234 &amp; -a_4S234\\
a_2C2+a_3C23+a_4C234 &amp; a_3C23+a_4C234 &amp; a_4C234\\
\end{array}\right)
$$</p>
<h2 id="levenberg-marquart"><a class="header" href="#levenberg-marquart">Levenberg-marquart</a></h2>
<p>Une fois la fonction et sa jacobienne créées, nous pouvons sortir l'algorithme d'optimisation/minimisation de notre choix. Dans cet exemple, nous avons choisi Levenberg-Marquart.</p>
<p>En définissant <strong>Ɛ</strong> l'état de notre système <strong>(θ<sub>2</sub>,θ<sub>3</sub>,θ<sub>4</sub>)</strong>. L'algorithme agit de cette façon :</p>
<pre><code>Jusqu'à N_max itérations :
    Objectif = F(Ɛ)
    Résidus = 2*J(F(Ɛ))*F(Ɛ)
    Si Résidus est très petit:
        On valide Ɛ et on sort de l'algorithme
    Sinon:
        Ɛ_new = Ɛ - (J(F(Ɛ))*F(Ɛ) + λ*I_3)^{-1} * J(F(Ɛ))*F(Ɛ)
        Si ||F(Ɛ_new)|| &lt; ||F(Ɛ)||:
            Ɛ = Ɛ_new
            On diminue λ
        Sinon:
            On augmente λ 
</code></pre>
<p>A la sortie de cet algorithme, si Résidus est bien très petit, alors les angles <strong>Ɛ=(θ<sub>2</sub>,θ<sub>3</sub>,θ<sub>4</sub>)</strong> sont très proche de la valeure parfaite que l'on aurait trouvé avec la méthode géométrique.</p>
<h2 id="conclusion-et-amélioration-1"><a class="header" href="#conclusion-et-amélioration-1">Conclusion et amélioration</a></h2>
<p>Nous avons donc à la fin de notre algorithme les angles <strong>θ<sub>2</sub></strong>,<strong>θ<sub>3</sub></strong> et <strong>θ<sub>4</sub></strong> de plus nous avions déjà déterminé <strong>θ<sub>1</sub></strong> tout au début. La cinématique inverse est donc finie.</p>
<p>Cette méthode permet de juste devoir calculer la cinématique directe et d'utiliser un algorithme itératif qui va résoudre la cinématique inverse pour nous. Un gros avantage de cette méthode est que peut importe le nombre d'angles à déterminer, une solution sera trouvée tant qu'assez d'itérations sont faites. Le problème de cette méthode est qu'on ne peut pas toujours se permettre de faire plein d'itérations.</p>
<p>Si des contraintes vous sont imposées, vous pouvez aussi insérer ces contraintes au milieu de l'algorithme Levenberg-Marquart.
Par exemple, des bornes peuvent être ajoutées afin de restreindre les variables à certaines valeurs.
Juste après avoir calculé <strong>Ɛ_new</strong>, vous pouvez faire une condition du type :<br />
<code> Si Ɛ_new &gt; Ɛ_max, Alors Ɛ_new = Ɛ_max</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-3"><a class="header" href="#code-3">Code</a></h1>
<p>Fonctions de l'implémentation de <strong>Levenberg-Marquart</strong> et de sa fonction assosiée au problème <a href="./4_dof.html">4 DOF</a>.</p>
<p>En dessous se trouve le code principal.</p>
<pre><code class="language-python">&quot;&quot;&quot;
Date: 2023-03-27
Author: Romain
This script was developed for target positionning with different algorithms.
&quot;&quot;&quot;

import numpy as np

def non_linear_least_squares_functions(pos, joints):
    print(f'{joints}')

    # f(x) returns the residuals
    f = lambda x: np.array([joints[1]*np.cos(x[0]) + joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]) - np.sqrt(pos[0]**2 + pos[1]**2),
                joints[0] + joints[1]*np.sin(x[0]) + joints[2]*np.sin(x[0]+x[1]) + joints[3]*np.sin(x[0]+x[1]+x[2]) - pos[2]])
    # Df(x) is the N by 2 derivative matrix
    Df = lambda x: np.array([[-joints[1]*np.sin(x[0]) - joints[2]*np.sin(x[0]+x[1]) - joints[3]*np.sin(x[0]+x[1]+x[2]), -joints[2]*np.sin(x[0]+x[1]) - joints[3]*np.sin(x[0]+x[1]+x[2]), -joints[3]*np.sin(x[0]+x[1]+x[2])],
                             [joints[1]*np.cos(x[0]) + joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]), joints[2]*np.cos(x[0]+x[1]) + joints[3]*np.cos(x[0]+x[1]+x[2]), joints[3]*np.cos(x[0]+x[1]+x[2])]])
    return f, Df

def levenberg_marquardt(f, Df, x0, lambda0, tol = 1e-2, kmax = 100):
    n = len(x0)
    x = x0
    lam = lambda0
    obj = np.zeros((0,1))
    res = np.zeros((0,1))
    for k in range(kmax):
        obj = np.vstack([obj, np.linalg.norm(f(x))**2])
        res = np.vstack([res, np.linalg.norm(2*Df(x).T @ f(x))])
        if np.linalg.norm(2*Df(x).T @ f(x)) &lt; tol:
            break
        xt = x - np.linalg.inv((Df(x).T @ Df(x)) + lam*np.eye(n)) @ (Df(x).T @ f(x))
        
        # handle 180° limit with 20° marge error (~10%*pi)
        xt[0] = np.clip(xt[0],  0.1 * np.pi, 0.9 * np.pi) #   0° - 180°
        xt[1] = np.clip(xt[1], -0.4 * np.pi, 0.4 * np.pi) # -90° - 90°
        xt[2] = np.clip(xt[2], -0.4 * np.pi, 0.4 * np.pi) # -90° - 90°
                

        if np.linalg.norm(f(xt)) &lt; np.linalg.norm(f(x)) :
            lam = 0.8*lam
            x = xt
        else:
            lam = 2.0*lam
    return x, {'Objective':obj, 'Residual':res}
</code></pre>
<p>Et ici le code principal faisant appel au code précédent.
Ils vous faut mettre votre position x,y,z voulue dans les variables au début du programme.</p>
<pre><code class="language-python">x = message.x
y = message.y
z = message.z

print('received message')
print('Objectif :')
print(f'X = {x}')
print(f'Y = {y}')
print(f'Z = {z}')
print('')

pos = [x, y, z] # vecteur de la position voulue
joints = [a1, a2, a3, a4] # vecteur avec la taille des différentes branches

# Target location using L-M with LLS estimation as starting point and lambda = 0.1
f, Df = lv.non_linear_least_squares_functions(pos, joints)
x_lm, history_lm = lv.levenberg_marquardt(f, Df, [0,0,0], 0.1, 1e-4)

thetas = np.concatenate([np.array([np.arctan2(y,x)*180/np.pi % 360fg]), np.degrees(x_lm)])
print(f&quot;{thetas}&quot;)        
print(f&quot;{thetas % 360}&quot;)

# I have a problem on theta1 that can be &gt; 180, AND MY SERVO CANNOT
if thetas[0] &gt; 180:
    thetas[0] -= 180
    thetas[1] = 180 - thetas[1]
    thetas[2] = 180 - thetas[2]
    thetas[3] = 180 - thetas[3]


print(f&quot;theta_1 = {thetas[0]}, theta_2 = {thetas[1]}, theta_3 = {thetas[2]}, theta_4 = {thetas[3]} &quot;)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
